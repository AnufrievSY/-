import os
import time
import re
from docxtpl import DocxTemplate, InlineImage
import pandas as pd

pas = os.getcwd()
to_pas = f'{os.getcwd()}\\Результат'

# Таблицы предоставленными организацией
# (были оставленны в изначальном виде для удобства дальнешего использования получателем):
# 1.Таблица с кодами для автозаполнения и наименованиями колонки из выгрузки;
df_code = pd.read_excel(f'{pas}/КОДЫ.xlsx', sheet_name=0)
# 2. Таблица с организациями учавствующими в проекте
organization = pd.read_excel(f'{pas}/КОДЫ.xlsx', sheet_name=1)
# 2. Таблица с целевыми группа учавствующими в проекте;
SRG = pd.read_excel(f'{pas}/КОДЫ.xlsx', sheet_name=2)
# 3. Таблица с необходимыми для обработки гражданами;
base = pd.read_excel(f'{pas}/Журнал регистрации формы сведений о ребенке.xlsx', sheet_name=0)
# 4. csv файл выгружаемый программой организации со всей информацией, по всем гражданам, которые потенциально
# могут учавствовать в проекте.
df_base = pd.read_csv(f'{pas}/выгрузка.csv', delimiter=';', low_memory=False)

# Добавление в "Журнал регистрации формы сведений о ребенке" колонок необходимых организации для дальнейшего анализа.
base['Возраст'] = ''  # Возраст гражданина
base['Адрес'] = ''  # Адрес места жительства
base['Учреждения'] = ''  # Центры учавствующие в проекте


# Функция для поиска значения в позии "Адресс". Если адрес найден единожды то возвращается его значение,
# если найдено несколько, то они объединяются и возвращается пустое значение, если не найдено ничего.
def check(a, check_value):
    if type(check_value) == str:
        check_result = [i for i in a if check_value in i]
    else:
        check_result = check_value
    if len(check_result) == 0:
        check_result = ''
    elif len(check_result) > 1:
        check_result = ', '.join([i for i in check_result if i != ''])
    else:
        check_result = check_result[0]
    return check_result


# Функция для поиска наименований имеющих определенные общие фразы.
def get_reg_index(db, column, reg_value):
    reg_index = [i for i in db[column].index if re.search(reg_value, db[column][i]) != None]
    return reg_index


# Функция которая подготавливает данные для заполнения предоставленных форм. Поиск осуществляется по СНИЛСУ гражданина,
# так как по заверениям организации данный пунк единственным наиболее достоверным и обязательно заполняемым при
# добавлении нового гражданину в базу.
def get_df(SNILS):
    df = df_code.copy()
    df['Значение'] = ''

    # Получаем из файла "выгрузка" необходимые сведения прописанные в "Журнал регистрации формы сведений о ребенке"
    columns = df.loc[df['таблица'] == 'выгрузка', 'Наименование']
    for index in columns.index:
        df['Значение'][index] = df_base.loc[df_base['СНИЛС'] == SNILS, columns[index]].values[0]
    # Добавляем значение СНИЛС
    df.loc[df['Наименование'] == 'СНИЛС', 'Значение'] = SNILS

    # Определяем значения полей "МУЖ" и "ЖЕН" исходя из значения "Пол"
    value = df.loc[df['Наименование'] == 'Пол', 'Значение'].values[0]
    df.loc[df['Наименование'] == value, 'Значение'] = 'X'

    # Таким же образом поступаем и со значением поля "Гражданство"
    value = df.loc[df['Наименование'] == 'Гражданство', 'Значение'].values[0]
    df.loc[df['Наименование'] == value, 'Значение'] = 'X'

    # Так как адрес наиболее некорректно заполняемая часть в базе данных организации и с ней возникает большое
    # колличество ошибок, было принято решения добавить альтернативный результат при возникновении ошибки.
    try:
        address = df.loc[df['Наименование'] == 'Адрес', 'Значение'].values[0].split(', ')
        df.loc[df['Наименование'] == 'индекс', 'Значение'] = address[0]
        df.loc[df['Наименование'] == 'Субъект РФ', 'Значение'] = address[1]
        df.loc[df['Наименование'] == 'Субъект РФ', 'Значение'] = address[1]
        df.loc[df['Наименование'] == 'Район', 'Значение'] = check(address, 'р-н')
        df.loc[df['Наименование'] == 'Населенный пункт', 'Значение'] = check(address, [check(address, i) for i in [' с', ' г', ' п']])
        df.loc[df['Наименование'] == 'улица', 'Значение'] = check(address, ' ул')
        df.loc[df['Наименование'] == 'дом', 'Значение'] = check(address, 'д. ')
        df.loc[df['Наименование'] == 'корпус', 'Значение'] = check(address, 'корп. ')
        df.loc[df['Наименование'] == 'строение', 'Значение'] = check(address, 'стр. ')
        df.loc[df['Наименование'] == 'квартира', 'Значение'] = check(address, 'кв. ')
    except Exception as e:
        df.loc[df['Наименование'] == 'индекс', 'Значение'] = df.loc[df['Наименование'] == 'Адрес', 'Значение'].values
        print(f'ERROR: Ошибка обработки адреса\nСНИЛС: {SNILS}\nПричина: {e}')

    # Избавимся теперь от временных меток оставив только дату
    for reg_index in get_reg_index(df, 'Наименование', 'Дата') + get_reg_index(df, 'Наименование', 'Инвалидность установлена'):
        df.loc[reg_index, 'Значение'] = df.loc[reg_index, 'Значение'].split(' ')[0]

    # Получаем регистрационный номер записи о гражданине из таблицы "Журнал регистрации формы сведений о ребенке"
    df.loc[df['Наименование'] == '№', 'Значение'] = base.loc[base['СНИЛС'] == SNILS, '№ п/п'].values

    # Определяем номер Бюро которое проводило осведетельствование зная, что номер акта экспертизы состоит из номера
    # дела, номера бюро, номера региона и года проведения
    df.loc[df['Наименование'] == 'Бюро', 'Значение'] = \
        df.loc[df['Наименование'] == 'Номер акта', 'Значение'].values[0].split('.')[1]

    # Прописывание значений ЦРГ (Целевой Реабилитационной Группы). При этом в отдельных случаях значение ЦРГ не было
    # прописано в таблицы "Журнал регистрации формы сведений о ребенке", таким образом было принято решение указывать
    # пользователю на такие ошибки но продолжать работу. Номер ЦРГ присваивает на основании основного заболевания и
    # сопутсвующего, возможно в будущем этот момент можно будет добавить скрипт, который бы сам определял группу, на
    # основании кодов МКБ имеющихся в "Выгрузке".
    try:
        main_group = int(base.loc[base['СНИЛС'] == SNILS, 'ЦРГ подгруппа №'].values[0])
        under_group = base.loc[base['СНИЛС'] == SNILS, 'ЦРГ подгруппа №'].values[0]
        df.loc[df['Наименование'] == 'ЦРГ группа №', 'Значение'] = main_group
        df.loc[df['Наименование'] == 'ЦРГ группа наименование', 'Значение'] = \
            SRG.loc[SRG['N п/п'] == int(main_group), 'Целевая реабилитационная группа'].values[0]
        df.loc[df['Наименование'] == 'ЦРГ подгруппа №', 'Значение'] = under_group
        df.loc[df['Наименование'] == 'ЦРГ подгруппа наименование', 'Значение'] = \
            SRG.loc[SRG['N п/п.1'] == under_group, 'Целевая реабилитационная подгруппа'].values[0]
    except Exception as e:
        print(f'ERROR: Ошибка обработки ЦРГ\nСНИЛС: {SNILS}')
        print(e)

    # Отмечаем позиции при которых установлены степени выраженности ограничений основных категорий жизнедеятельности
    for reg_index in get_reg_index(df, 'Наименование', '(степень)'):
        value = df['Значение'][reg_index]
        if value != 'Не установлено':
            name = df['Наименование'][reg_index][:-10] + f' ({value})'
            df.loc[df['Наименование'] == name, 'Значение'] = 'X'
            df['Значение'][reg_index] = 'X'
        else:
            df['Значение'][reg_index] = ''

    # Поиск рекомундуемого реабилитационного учреждения на основании ЦРГ, места жительства и возраста
    age = int(df.loc[df['Наименование'] == 'Возраст', 'Значение'].values[0].split(' ')[0])
    town = ' '.join(df.loc[df['Наименование'] == 'Населенный пункт', 'Значение'].values[0].split(' ')[:-1])
    main_group = df.loc[df['Наименование'] == 'ЦРГ группа №', 'Значение'].values[0]
    org = organization.loc[organization['ЦРГ'] == main_group]
    if age >= 14:
        org = org.loc[org['Возраст'] == '14-17']
    else:
        org = org.loc[org['Возраст'] == 'до 14']
    town_index = get_reg_index(org, 'Муниципальные образования (управленческие округа)', town)
    if len(town_index) == 0:
        org = org.loc[org['Муниципальные образования (управленческие округа)'] == 'Свердловская область (остальные МО)']
    else:
        org = org.loc[town_index]
    df.loc[df['Наименование'] == 'рекомендуемое учреждение', 'Значение'] = '; '.join(
        org['Наименование учреждения'].values)

    return df


# Функция которая добовляет изображения закрешного или не закрашеного квадрата в ключи начинающиеся со знака 'i'
# интерпретируемого как image.
def get_image(c, doc):
    for k, v in c.items():
        if 'i' in k:
            if v == 'X':
                c[k] = InlineImage(doc, f'{pas}/box_true.png')
            elif v == '':
                c[k] = InlineImage(doc, f'{pas}/box_false.png')
    return c


# Функция которая подставляет в предоставленные шаблоны файлов значения по соответсвующему ключу.
def processing(snils):
    try:
        df_ = get_df(snils)  # Получаем все сведения из файда 'выгрузка' соответсвующие определенному СНИЛСу
        try:
            for doc_name in ['МСЭ', 'родители', 'учреждение', 'ФСС']:
                doc = DocxTemplate(f'{pas}/Бланк Формы сведений о ребенке ({doc_name}).docx')  # загружаем шаблон
                df_ = df_.dropna(axis=0, how='any', subset=f'код({doc_name})')  # удаляем строки с отсутвующим кодом

                # составляем словарь для заполнения шаблона {ключ используемый в шаблоне: его значение}
                context = {df_[f'код({doc_name})'][j]: df_['Значение'][j] for j in df_.index}
                context = get_image(context, doc)  # и добавляем изображения там где это необходимо

                doc.render(context)  # заполняем шаблон
                # прописываем имя файлу по формату "Фамилия.И.О.Название шаблона"
                name = f"{context['p_1_1']}.{list(context['p_1_2'])[0]}.{list(context['p_1_3'])[0]}.({doc_name})"
                # добавляем папки подведомств организации и сохраняем туда получившийся файл
                if not os.path.isdir(f"{to_pas}\\Бюро {context['p_0_2']}"):
                    os.mkdir(f"{to_pas}\\Бюро {context['p_0_2']}")
                doc.save(f"{to_pas}\\Бюро {context['p_0_2']}\\{name}.docx")

            # В конце добавляем в таблицу 'Журнал регистрации формы сведений о ребенке.xlsx' полученые сведения:
            # 1. номере дела
            number = f"{context['p_0_1']}.{context['p_0_2']}.66/2022"
            base.loc[base.loc[base['СНИЛС'] == snils].index[0],
                     'Форма № (порядковый, номер бюро, код Сверд. обл./год)'] = number
            # 2. возраст гражданина
            base.loc[base.loc[base['СНИЛС'] == snils].index[0], 'Возраст'] = context['p_3_0']
            # 3. Адрес места жительства
            address = ' '.join(df_.loc[df_['Наименование'] == 'Адрес', 'Значение'].values[0].split()[1:])
            base.loc[base.loc[base['СНИЛС'] == snils].index[0], 'Адрес'] = address
            # 4. Рекомендуемые учреждения для реабилитации
            base.loc[base.loc[base['СНИЛС'] == snils].index[0], 'Учреждения'] = \
                df_.loc[df_['Наименование'] == 'рекомендуемое учреждение', 'Значение'].values[0]
            base.to_excel(f'{pas}/Журнал регистрации формы сведений о ребенке.xlsx', index=False)
            return f'{snils}: OK'
        except Exception as e:
            return f'UNKNOWN ERROR: {e}\nСНИЛС: {snils}'
    except IndexError:
        return f'{snils}: Нет такого гражданина в выгрузке'
    except Exception as e:
        return f'UNKNOWN ERROR: {e}\nСНИЛС: {snils}'


# Формируем список лиц которых необходимо отыскать в таблице "выгрузка.xlsx"
snils_list = base['СНИЛС'].to_list()

# Расчитываем время необходимое для обработки всех позиций, на основании заполнения первой позиции
start = time.time()
processing(snils_list[0])
final = time.time()
time_all = (len(snils_list)-1) * (final - start)
if time_all > 60:
    time_all /= 60
    print(f'\nОбработка займет примерно {time_all:.2f} минут.\n')
else:
    print(f'\nОбработка займет примерно {time_all:.2f} секунд.\n')

# Начинаем заполнение
for i in snils_list[1:]:
    print(processing(i))

# В результате, данный скрипт позволил в значительной степени увеличить производительность труда связанного с
# проектом организации, за счет ускорения процесса заполнения форм отчетности и уменьшения колличества ошибок, нежели
# при ручном заполнении.
